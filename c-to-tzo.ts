/*
Very dirty C to Tzo translator.
Not perfect. Can not translate everything, but does its best.
Needs human intervention!
*/

import glob from "glob";
import fs from "fs";
import path from "path";
import { format } from "astyle";

const files = glob.sync("./comm/**/*.c");

async function main() {
  files.forEach(async file => {
    try {
      if (file.includes("fixed")) {
        return;
      }
      const dirname = path.basename(path.dirname(file));
      const base = path.dirname(file);
      const cfile = fs.readFileSync(file).toString();
      await transform(cfile, dirname, base, file);
    } catch (e) {
      console.warn(`Could not parse ${file}`);
      throw e;
    }
  });
}

async function transform(cfile, dirname, base, cfilename) {
  const formatted = await format(cfile, "--add-braces --style=allman"); // format for easier parsing and rewriting
  let lines = formatted.split(/\r?\n/gi); // extract lines
  let foundContextValues = {}; // keep track of required context values 


  // don't do anything if file already appears to have been parsed
  if (!lines[0].startsWith("//Copyright ") || lines[0].startsWith("/* Generated by c-to-tzo")) {
    console.log(`skipping ${cfilename}`);
    return;
  }

  // replace line comments with block comments
  lines = lines.map(line => {
    const i = line.indexOf("//");
    if (i > -1) {
      line = line.replace(/\/\//i, "/*") + " */";
    }
    return line;
  });

  const static_start_block = [
    `// "Intro" goto`,
    `// nop #peace`,
    `// "PEACE" emit exit`
  ]

  let inFunction = false;
  let bracesCount = 0;
  let inSwitch = false;
  let removeSwitchDupInstrLineIndices = []; // line indices for switch statement case handlings on which we later on need to remove the 'dup' opcode invocation
  let lastSeenCaseIndex = undefined;
  let wasInIfStatement = false; // tracks if we were in an if statement and need to add "jgz" to the end
  let ifStmntOpens = 0;
  let ifStmntCloses = 0;
  let inMultilineIfStatement = false;
  lines = lines.map((line, linenr) => {
    const stripped = line.trim();
    let tokens = [];
    function o(tzoCode) {
      tokens.push(tzoCode);
    }
    function countChar(char) {
      return stripped.split('').filter(x => x === char).length;
    }
    function fStateVal(valName, initialValue?) {
      foundContextValues[valName] = initialValue !== undefined ? initialValue : 0;
    }

    // function and switch detection
    if (stripped.startsWith("static void")) {
      inFunction = true;
    }
    if (stripped.includes("switch (")) {
      inSwitch = true;
    }

    // braces: add braces syntax
    if (inFunction && !inSwitch && stripped === "{") {
      bracesCount++;
      if (bracesCount > 1) { // don't add the first brace
        o("{");
      }
    }
    if (inFunction && !inSwitch && stripped === "}") {
      bracesCount--;
      if (inFunction && bracesCount === 0) {
        inFunction = false;
        o("getResponse goto exit }");
      } else {
        o("}");
      }
    }

    // switch handling
    if (inSwitch && stripped === "}") {
      inSwitch = false;
      removeSwitchDupInstrLineIndices.push(lastSeenCaseIndex);
      lastSeenCaseIndex = undefined;
    }
    if (inSwitch && stripped.includes("break")) {
      o("}");
    }
    if (inSwitch && stripped.includes("case")) {
      lastSeenCaseIndex = linenr;
      const grp = stripped.match(/case (.*?):/);
      o(`dup ${grp[1]} eq jgz {`);
    }

    // if statement handling and tracking -- the relevant opcodes are included later (further down in this source code)
    if (stripped.includes("if ")) {
      const numOpen = countChar('(');
      const numClose = countChar(')');
      if (numOpen === numClose) {
        // one-line if statement; no advanced tracking needed!
        wasInIfStatement = true;
      } else {
        // multi-line if statement; need to track when the if statement closes
        inMultilineIfStatement = true;
      }
    }
    if (inMultilineIfStatement) {
      const numOpen = countChar('(');
      const numClose = countChar(')');
      ifStmntOpens += numOpen;
      ifStmntCloses += numClose;
      if (ifStmntCloses === ifStmntOpens) { // it's done! ensure we append the jgz later!
        inMultilineIfStatement = false;
        wasInIfStatement = true;
      }
    }

    // PLAYER_SAID
    if (stripped.includes("PLAYER_SAID")) {
      const psaid = stripped.match(/PLAYER_SAID\s*\(R, (.*?)\)/)[1];
      fStateVal("player_said");
      o(`"player_said" getContext "${psaid}" eq`);
    }

    // NPCPhrase
    if (stripped.includes("NPCPhrase")) {
      const n = stripped.match(/NPCPhrase\s*\((.*?)\)/)[1];
      o(`"${n}" emit`);
    }

    // DISABLE_PHRASE
    if (stripped.includes("DISABLE_PHRASE")) {
      const n = stripped.match(/DISABLE_PHRASE\s*\((.*?)\)/)[1];
      o(`"${n}" disableOption`);
    }

    // PHRASE_ENABLED
    if (stripped.includes("PHRASE_ENABLED")) {
      const grp = stripped.match(/PHRASE_ENABLED\s*\((.*?)\)/);
      o(`"${grp[1]}" optionEnabled 1 eq`);
    }

    // SET_GAME_STATE
    if (stripped.includes("SET_GAME_STATE")) {
      const grp = stripped.match(/SET_GAME_STATE\s*\((.*?),\s*(.*?)\)/);
      fStateVal(grp[1], grp[2]);
      o(`${grp[2]} "${grp[1]}" setContext`);
    }

    // GET_GAME_STATE
    if (stripped.includes("GET_GAME_STATE")) {
      const grp = stripped.match(/(\!?)GET_GAME_STATE\s*\((.*?)\)/);
      fStateVal(grp[2]);
      o(`"${grp[2]}" getContext${grp[1].length > 0 ? " not" : ""}`);
    }

    // Response
    if (stripped.includes("Response")) {
      const grp = stripped.match(/Response\s*\((.*?),\s*(.*?)\)/);
      o(`"${grp[1]}" ppc 4 + { "${grp[1]}" "player_said" setContext "${grp[2]}" goto } response`);
    }

    // Global state byte?
    if (stripped.includes("LOBYTE (GLOBAL")) {
      const grp = stripped.match(/(\!?)LOBYTE\s*\(GLOBAL\s*\(CurrentActivity\)\)\s*\=\=\s*([^)]*)/);
      fStateVal(grp[2]);
      o(`"${grp[2]}" getContext${grp[1].length > 0 ? " not" : ""}`);
    }

    // Function/State header
    if (stripped.includes("(RESPONSE_REF R)")) {
      const grp = stripped.match(/(.*?)\s*\(RESPONSE_REF R\)/);
      o(`{ nop #${grp[1]}`);
    }

    // and/or. This needs to be done at the end as Tzo is a stack machine!
    if (stripped.includes("&&")) {
      o("and");
    }
    if (stripped.includes("||")) {
      o("or");
    }

    // add if jumper and reset if statement paren tracking
    if (wasInIfStatement) {
      wasInIfStatement = false;
      inMultilineIfStatement = false;
      ifStmntOpens = 0;
      ifStmntCloses = 0;
      o("jgz");
    }

    return `${line}${tokens.length > 0 ? ` // ${tokens.join(" ")}` : ''}`;
  });

  // fix all the dangling switch case `dup` instructions
  removeSwitchDupInstrLineIndices.forEach(linenr => {
    lines[linenr] = lines[linenr].replace(" dup ", " ");
  });

  // prefix state initialization
  lines = ["/* Generated by c-to-tzo */"].concat(Object.entries(foundContextValues).map(entry => {
    return `// ${entry[1]} "${entry[0]}" setContext`;
  })).concat(static_start_block).concat(lines);



  // write outgoing file
  const out = lines.join("\n");
  fs.writeFileSync(`${base}/${dirname}.fixed.c`, out);
}

main().then(console.log).catch(console.error);